---
title: 浏览器解析
date: 2020-08-10 14:24:53
tags: browser
categories: Http
cover: https://images.pexels.com/photos/1482061/pexels-photo-1482061.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260
---



### 基本概念

#### 进程和线程

>**进程**是操作系统的进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。

>**线程**是操作系统能够进行运算调度的最小单元，一个进程可以有多个线程，每个线程并行执行不同的任务。

简单说就是：当启动程序时，系统会创建一个进程来执行任务代码，同时会为任务分配内存空间，该应用程序的运行状态都保存在内存空间里，当程序关闭时，内存就会被回收。进程可以启动更多进程来执行任务，如果两个进程进行通信，需要使用进程间通信管道IPC来传递数据，很多程序都是多进程的，主要是防止某一个进程卡死，因为进程是相互独立的，这样就不会影响整个程序。进程可以创建更多的任务来执行任务，来创建线程来并行执行任务，同一进程下的线程可以互相通信，共享数据。

单进程浏览器的问题
1. 不稳定：其中一个线程卡死可能导致整个进程不问题
2. 不安全：js解析能访问整个进程的数据
3. 不流程：处理任务过多
 

> 浏览器可分成多个进程：浏览器进程(负责除标签页的用户界面包括地址栏书签后退前进按钮)、缓存进程()、网络进程(发送接收网络请求)、GPU进程(整个浏览器界面的渲染)、插件进程(控制网站所使用的插件)、渲染器进程(渲染tab标签内的内容，每个tab默认创建一个渲染器进程)

Chrome四种进程模型
1. **Process-per-site-instance** 就是你打开一个网站，然后从这个网站链开的一系列网站都属于一个进程。这是Chrome的默认模式。
2. **Process-per-site** 同域名的网站放在同一进程
3. **Process-per-tab** 每个tab页一个进程
4. **Single Process** 传统浏览器模式，没有多进程，只有多线程


### 浏览器输入URL发生了什么

1. 浏览器进程的ui线程捕捉到你的输入内容，如果访问的是网址ui线程会启动一个网络线程来请求dns进程域名解析，连接服务器获取数据；如果输入的内容不是网址而是关键字，浏览器使用默认搜索引擎来查询。
2. 浏览器获取到数据会通过safebrowser来检查站点是否安全，用户也能强制访问
3. 当内容准备完毕并通过安全校验，网络线程通知ui线程
4. ui线程创建一个渲染器进程来渲染页面，并通过进程通信管道ipc将数据传递给渲染器进程的主线程
5. 渲染器进程的作用就是将html，css，js，image等资源渲染成用户可交互的web页面
6. 渲染器主线程解析html构造以document为根节点的DOM树（css、图片这些资源可以通过下载或缓存直接加载，但是遇到script会停止dom树的解析，因为js可能改变dom树结构这就是为什么要把script标签放在合适的位置，在script标签async和defe异步加载外部脚本【如果async属性存在，脚本将异步执行，只要它是可用的，如果async属性不存在，而defer属性存在，脚本将会在页面完成解析后执行，如果都不存在，那么脚本会在useragent解析页面之前被取出并立刻执行】）
7. 进行样式计算，根据DOM树和计算后的样式生成layout tree( DOM和layout tree并不是一一对应的，DOM的display：none不会出现在layout tree，layout tree的伪类也不会出现在dom树)
8. 通过遍历layout tree生成绘制顺序表，生成layer tree
9. 主线程将绘制顺序表和layer tree传递给合成器线程
10. 合成器线程按照规则进行分图层，把图层分成更小的图块传递给栅格线程
11. 栅格线程进程栅格化，将栅格化之后的draw quads 图块信息传递回合成器线程
12. 根据这些信息，合成器线程生成一个合成器帧frame，通过IPC传递给浏览器进程
13. 浏览器进程再传递GPU进程进行渲染
14. 显示到屏幕


当改变元素尺寸位置时会触发会重新进程样式计算(7)布局绘制以及之后的流程，我们称之为**重排**
当改变元素颜色时会不会触发布局，但是会进行样式计算、绘制以及之后的流程，我们称之为**重绘**

一帧为60ms，页面动画看上去比较流畅。布局、绘制、js执行都是运行在主线程当一帧结束时，js会拿到线程的使用权，如果js执行时间过长，会导致下一帧开始js还没及时归还主线程导致下一帧动画没按时渲染导致页面动画卡顿。

**优化1**：通过requestAnimationFrame(在每一帧被调用，在每一帧用完前暂停js执行归还主线程，所以在下一帧主线程可以按时执行布局和绘制)
**优化2transform**不会布局、绘制和样式计算，运行在合成器线程和栅格线程，不会受到主线程js的影响

